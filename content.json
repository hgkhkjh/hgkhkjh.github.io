{"meta":{"title":"万事胜意","subtitle":"","description":"","author":"Girl Xu","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"面试题 css清除浮动的方法","slug":"面试题 css清除浮动的方法","date":"2022-04-07T08:43:45.000Z","updated":"2022-04-07T08:46:35.865Z","comments":true,"path":"2022/04/07/面试题 css清除浮动的方法/","link":"","permalink":"http://example.com/2022/04/07/%E9%9D%A2%E8%AF%95%E9%A2%98%20css%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95/","excerpt":"","text":"浮动的产生 1、普通流定位 static（默认方式）普通流定位，又称为文档流定位，是页面元素的默认定位方式页面中的块级元素：按照从上到下的方式逐个排列页面中的行内元素：按照从左到右的方式逐个排列但是如何让多个块级元素在一行内显示?这里就引出了浮动定位 2、浮动定位 floatfloat属性 取值为 left&#x2F;right这个属性原本不是用来布局的，而是用来做文字环绕的，但是后来人们发现做布局也不错，就一直这么用了，甚至有些时候都忘了用他做文字环绕 3、相对定位 relative元素会相对于它原来的位置偏移某个距离，改变元素位置后，元素原本的空间依然会被保留语法属性：position取值：relative配合着 偏移属性(top&#x2F;right&#x2F;bottom&#x2F;left)实现位置的改变 4、绝对定位 absolute如果元素被设置为绝对定位的话，将具备以下几个特征1、脱离文档流-不占据页面空间2、通过偏移属性固定元素位置3、相对于 最近的已定位的祖先元素实现位置固定4、如果没有已定位祖先元素，那么就相对于最初的包含块(body,html)去实现位置的固定语法属性：position取值：absolute配合着 偏移属性(top&#x2F;right&#x2F;bottom&#x2F;left)实现位置的固定 5、固定定位 fixed将元素固定在页面的某个位置处，不会随着滚动条而发生位置移动语法属性：position取值：fixed配合着 偏移属性(top&#x2F;right&#x2F;bottom&#x2F;left)实现位置的固定 第一种 clear:both 取值：1、none默认值，不做任何清除浮动的操作2、left清除前面元素左浮动带来的影响3、right清除前面元素右浮动带来的影响4、both清除前面元素所有浮动带来的影响优势：代码量少 容易掌握 简单易懂本声明。 设置浮动 123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; div&#123; width: 300px; height: 300px; border: 2px solid white; background-color: pink; float: left; &#125;&lt;/style&gt;&lt;body&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt; 设置clear:both清除浮动 clear：both：本质就是闭合浮动， 就是让父盒子闭合出口和入口，不让子盒子出来 第二种 额外标签法 额外标签法（在最后一个浮动标签后，新加一个标签，给其设置clear：both；） 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .div&#123; width: 300px; height: 300px; border: 2px solid white; background-color: pink; float: left; &#125; .father&#123; border: 1px solid steelblue; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div style=&quot;clear: both;&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt; 第三种父元素添加overflow:hidden 或 auto1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .div&#123; width: 300px; height: 300px; border: 2px solid white; background-color: pink; float: left; &#125; .father&#123; border: 1px solid steelblue; overflow:hidden &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt; 第四种 父元素添加：after伪类清除浮动123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .div &#123; width: 300px; height: 300px; border: 2px solid white; background-color: pink; float: left; &#125; .father &#123; border: 1px solid steelblue; &#125; .father:after &#123; content: &quot;&quot;; display: block; clear: both; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt; 第五种父元素添加display: table;123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; .div &#123; width: 300px; height: 300px; border: 2px solid white; background-color: pink; float: left; &#125; .father &#123; border: 1px solid steelblue; display: table; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;div class=&quot;div&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script&gt;&lt;/script&gt;","categories":[],"tags":[]},{"title":"三栏布局8种","slug":"三栏布局8种","date":"2022-03-26T10:28:45.000Z","updated":"2022-03-26T14:39:08.304Z","comments":true,"path":"2022/03/26/三栏布局8种/","link":"","permalink":"http://example.com/2022/03/26/%E4%B8%89%E6%A0%8F%E5%B8%83%E5%B1%808%E7%A7%8D/","excerpt":"","text":"浮动实现三栏布局让左边的盒子和右边的盒子左右浮动留出两边盒子的位置（利用padding） 这种布局方式，dom结构必须是先写浮动部分，然后再中间块，否则右浮动块会掉到下一行。 2.浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的， 浮动元素脱离文档&gt;流，要做清除浮动， 这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。3.主要内容无法最先加载，当页面内容较多时会影响用户体验 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; *&#123; margin: 0px; padding: 0px; height: 700px; &#125; .left &#123; width: 100px; background-color: aqua; float: left; &#125; .main &#123; background-color: brown; margin-left: 100px; margin-right: 200px; &#125; .right &#123; width: 200px; background-color: aquamarine; float: right; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 定位实现三栏布局让两边的盒子定位固定在让中间的盒子流出空位 绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; *&#123; margin: 0px; padding: 0px; height: 700px; &#125; .left &#123; width: 100px; background-color: aqua; position: absolute; left: 0px; &#125; .main &#123; background-color: brown; margin-left: 100px; margin-right: 200px; &#125; .right &#123; width: 200px; background-color: aquamarine; position: absolute; right: 0px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; flex实现三栏布局给父级设置display：flex优点：简单实用，未来的趋势缺点：需要考虑浏览器的兼容性 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; height: 700px; &#125; .container &#123; display: flex; &#125; .left &#123; width: 100px; background-color: aqua; &#125; .main &#123; background-color: brown; flex: 1; &#125; .right &#123; width: 200px; background-color: aquamarine; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; table实现三栏布局给父级设置display：table 然后让子元素都是 display: table-cell; 表格布局的兼容性很好，在flex布局不兼容的时候，可以尝试表格布局。表格布局也是有缺陷的，当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; height: 700px; &#125; .left &#123; width: 100px; background-color: aqua; display: table-cell; &#125; .main &#123; background-color: brown; display: table-cell; &#125; .right &#123; width: 200px; background-color: aquamarine; display: table-cell; &#125; .container &#123; display: table; width: 100%; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 网格布局（grid布局）只对父级进行操作设置这些属性 display: grid; grid-template-columns（康len（四声）次）: 100px auto 200px;设置每个宽度 grid-template-rows: 700px;设置每个高度优点：CSS新标准，创建网格布局最强大和最简单的工具，可以将页面分成具有简单属性的行和列缺点：有兼容性问题 12345678910111213141516171819202122232425262728293031323334353637383940&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; .left &#123; background-color: aqua; &#125; .main &#123; background-color: brown; &#125; .right &#123; background-color: aquamarine; &#125; .container &#123; display: grid; grid-template-columns: 100px auto 200px; grid-template-rows: 700px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; calc（靠克）布局calc可以计算像素，动态生成宽度 给中间盒子的宽度设置calc就行了但是每个元素都要设置浮动 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; .left &#123; background-color: aqua; width: 100px; height: 700px; &#125; .main &#123; background-color: brown; width: calc(100% - 300px); height: 700px; &#125; .right &#123; background-color: aquamarine; width: 200px; height: 700px; &#125; .container &#123; width: 100%; &#125; .container&gt;div &#123; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 圣杯布局让body留出左右盒子的位置（margin或者padding）让中间盒子撑满他就是width：100%然后这是左盒子和右盒子就被挤到下面来了，右盒子的话好上去就是设置margin：-200px就可以但是左盒子之呢设置margin-left：100%然后再利用定位设置他的位置就是left：-100px因为我们不知道中间的盒子到底多宽 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; .left &#123; background-color: aqua; width: 100px; height: 700px; margin-left: -100%; position: relative; left: -100px; &#125; .main &#123; background-color: brown; width: 100%; height: 700px; &#125; .right &#123; background-color: aquamarine; width: 200px; height: 700px; right: -200px; margin-right: -200px; &#125; body &#123; margin-left: 100px; margin-right: 200px; background-color: chartreuse; &#125; div &#123; float: left; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt;Main&lt;/div&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 双飞翼布局吧中间的元素提前，给他中间在放一个盒子，这个盒子里面设置内容，给这个盒子设置margin留出左右盒子的空间，左盒子直接给他来个 margin-left: -100%;有盒子来个 margin-left: -200px;双飞翼和圣杯都需要三栏里面的盒子设置 float: left; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;style&gt; * &#123; margin: 0px; padding: 0px; &#125; .left &#123; background-color: aqua; width: 100px; height: 700px; margin-left: -100%; &#125; .main &#123; background-color: brown; width: 100%; height: 700px; &#125; .right &#123; background-color: aquamarine; width: 200px; height: 700px; margin-left: -200px; &#125; div &#123; float: left; &#125; .inner&#123; margin: 0px 200px 0px 100px; &#125;&lt;/style&gt;&lt;body&gt; &lt;div class=&quot;main&quot;&gt; &lt;div class=&quot;inner&quot;&gt; Main &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;left&quot;&gt;Left&lt;/div&gt; &lt;div class=&quot;right&quot;&gt;Right&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[],"tags":[]},{"title":"http知识点","slug":"http知识点","date":"2022-03-25T16:00:00.000Z","updated":"2022-03-26T14:35:37.952Z","comments":true,"path":"2022/03/26/http知识点/","link":"","permalink":"http://example.com/2022/03/26/http%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"1.get post区别从缓存的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。从编码的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，而 POST 没有限制。从参数的角度，GET 一般放在 URL 中，因此不安全，POST 放在请求体中，更适合传输敏感信息。从幂等性的角度，GET是幂等的，而POST不是。(幂等表示执行相同的操作，结果也是相同的)从TCP的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 header 部分，如果服务器响应 100(continue)， 然后发 body 部分。(火狐浏览器除外，它的 POST 请求只发一个 TCP 包) 什么是幂等幂等通俗的来讲就是指同一个请求执行多次和仅执行一次的效果完全相等。这里来扯出幂等主要是为了处理同一个请求重复发送的情况，假如在请求响应之前失去连接，如果这个请求时幂等的，那么就可以放心的重发一次请求。所以可以得出get请求时幂等的，可以重复发送请求，post请求时不幂等的，重复请求可能会发生无法预知的后果。 网络模型网络是一个复杂的系统，不仅包括大量的应用程序、端系统、通信链路、分组交换机等，还有各种各样的协议组成，那么现在我们就来聊一下网络中的协议层次。为了给网络协议的设计提供一个结构，网络设计者以分层(layer)的方式组织协议，每个协议属于层次模型之一。每一层都是向它的上一层提供服务(service)，即所谓的服务模型(service model)。每个分层中所有的协议称为 协议栈(protocol stack)。因特网的协议栈由五个部分组成：物理层、链路层、网络层、运输层和应用层。我们采用自上而下的方法研究其原理，也就是应用层 -&gt; 物理层的方式。 应用层应用层是网络应用程序和网络协议存放的分层，因特网的应用层包括许多协议，例如我们学 web 离不开的 HTTP，电子邮件传送协议 SMTP、端系统文件上传协议 FTP、还有为我们进行域名解析的 DNS 协议。应用层协议分布在多个端系统上，一个端系统应用程序与另外一个端系统应用程序交换信息分组，我们把位于应用层的信息分组称为 报文(message)。 运输层因特网的运输层在应用程序断点之间传送应用程序报文，在这一层主要有两种传输协议 TCP和 UDP，利用这两者中的任何一个都能够传输报文，不过这两种协议有巨大的不同。TCP 向它的应用程序提供了面向连接的服务，它能够控制并确认报文是否到达，并提供了拥塞机制来控制网络传输，因此当网络拥塞时，会抑制其传输速率。UDP 协议向它的应用程序提供了无连接服务。它不具备可靠性的特征，没有流量控制，也没有拥塞控制。我们把运输层的分组称为 报文段(segment) 网络层因特网的网络层负责将称为 数据报(datagram) 的网络分层从一台主机移动到另一台主机。网络层一个非常重要的协议是 IP 协议，所有具有网络层的因特网组件都必须运行 IP 协议，IP 协议是一种网际协议，除了 IP 协议外，网络层还包括一些其他网际协议和路由选择协议，一般把网络层就称为 IP 层，由此可知 IP 协议的重要性。 链路层现在我们有应用程序通信的协议，有了给应用程序提供运输的协议，还有了用于约定发送位置的 IP 协议，那么如何才能真正的发送数据呢？ 为了将分组从一个节点（主机或路由器）运输到另一个节点，网络层必须依靠链路层提供服务。 链路层的例子包括以太网、WiFi 和电缆接入的 DOCSIS 协议，因为数据从源目的地传送通常需要经过几条链路，一个数据包可能被沿途不同的链路层协议处理，我们把链路层的分组称为 帧(frame)物理层虽然链路层的作用是将帧从一个端系统运输到另一个端系统，而物理层的作用是将帧中的一个个 比特 从一个节点运输到另一个节点，物理层的协议仍然使用链路层协议，这些协议与实际的物理传输介质有关，例如，以太网有很多物理层协议：关于双绞铜线、关于同轴电缆、关于光纤等等。 转自https://juejin.cn/post/6844904045572800525 HTTP 和 HTTPS 的区别HTTP 是一种 超文本传输协议(Hypertext Transfer Protocol)，HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范HTTP 主要内容分为三部分，超文本（Hypertext）、传输（Transfer）、协议（Protocol）。 超文本就是不单单只是本文，它还可以传输图片、音频、视频，甚至点击文字或图片能够进行超链接的跳转。 上面这些概念可以统称为数据，传输就是数据需要经过一系列的物理介质从一个端系统传送到另外一个端系统的过程。通常我们把传输数据包的一方称为请求方，把接到二进制数据包的一方称为应答方。 而协议指的就是是网络中(包括互联网)传递、管理信息的一些规范。如同人与人之间相互交流是需要遵循一定的规矩一样，计算机之间的相互通信需要共同遵守一定的规则，这些规则就称为协议，只不过是网络协议。 HTTP 和 HTTPS 的主要区别1.最简单的，HTTP 在地址栏上的协议是以 http:&#x2F;&#x2F; 开头，而 HTTPS 在地址栏上的协议是以 https:&#x2F;&#x2F; 开头2.HTTP 是未经安全加密的协议，它的传输过程容易被攻击者监听、数据容易被窃取、发送方和接收方容易被伪造；而 HTTPS 是安全的协议，它通过 密钥交换算法 - 签名算法 - 对称加密算法 - 摘要算法 能够解决上面这些问题。3.HTTP 的默认端口是 80，而 HTTPS 的默认端口是 443。 什么是无状态协议，HTTP 是无状态协议吗，怎么解决无状态协议(Stateless Protocol) 就是指浏览器对于事务的处理没有记忆能力。举个例子来说就是比如客户请求获得网页之后关闭浏览器，然后再次启动浏览器，登录该网站，但是服务器并不知道客户关闭了一次浏览器。HTTP 就是一种无状态的协议，他对用户的操作没有记忆能力。可能大多数用户不相信，他可能觉得每次输入用户名和密码登陆一个网站后，下次登陆就不再重新输入用户名和密码了。这其实不是 HTTP 做的事情，起作用的是一个叫做 小甜饼(Cookie) 的机制。它能够让浏览器具有记忆能力 解决办法：1.cookie2.JWT 机制 JWT 的 Cookie 信息存储在客户端，而不是服务端内存中。也就是说，JWT 直接本地进行验证就可以，验证完毕后，这个 Token 就会在 Session 中随请求一起发送到服务器，通过这种方式，可以节省服务器资源，并且 token 可以进行多次验证。JWT 支持跨域认证，Cookies 只能用在单个节点的域或者它的子域中有效。如果它们尝试通过第三个节点访问，就会被禁止。使用 JWT 可以解决这个问题，使用 JWT 能够通过多个节点进行用户认证，也就是我们常说的跨域认证。 UDP 和 TCP 的区别UDPUDP 的全称是 User Datagram Protocol，用户数据报协议。它不需要所谓的握手操作，从而加快了通信速度，允许网络上的其他主机在接收方同意通信之前进行数据传输。 UDP 的特点主要有 UDP 能够支持容忍数据包丢失的带宽密集型应用程序UDP 具有低延迟的特点UDP 能够发送大量的数据包UDP 能够允许 DNS 查找，DNS 是建立在 UDP 之上的应用层协议。 TCP 是什么TCP 的全称是Transmission Control Protocol ，传输控制协议。它能够帮助你确定计算机连接到 Internet 以及它们之间的数据传输。通过三次握手来建立 TCP 连接，三次握手就是用来启动和确认 TCP 连接的过程。一旦连接建立后，就可以发送数据了，当数据传输完成后，会通过关闭虚拟电路来断开连接。TCP 的主要特点有 TCP 能够确保连接的建立和数据包的发送TCP 支持错误重传机制TCP 支持拥塞控制，能够在网络拥堵的情况下延迟发送TCP 能够提供错误校验和，甄别有害的数据包。 TCP的拥塞控制主要针对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏几种拥塞控制方法 慢开始、拥塞避免、快重传和快恢复。 TCP 和 UDP 的不同 TCP 三次握手和四次挥手三次握手 但是在三次握手的情况下服务端收不到最后的ACK包不会认为链接建立成功其实三次握手的本质是解决 网络链接不可靠的问题 四次挥手 为什么 客服端要经过超市等待时间才能关闭链接这是为了保证服务端接收到ACK包如果客服端立即关闭链接这时ACK 包发生了丢失，服务端会一直进入等待确认状态如果有超时等待时间，当服务端没有收到ACK包时会重新发生FIN包，客服端会响应这个FIN包然后从新发送ACK包并刷新超时等待时间 摘抄：https://juejin.cn/post/6844904132067885064#heading-20","categories":[],"tags":[]},{"title":"Vue中如何检测数组的变化？","slug":"Vue中如何检测数组的变化？ ","date":"2022-03-25T10:28:45.000Z","updated":"2022-03-26T01:35:34.952Z","comments":true,"path":"2022/03/25/Vue中如何检测数组的变化？ /","link":"","permalink":"http://example.com/2022/03/25/Vue%E4%B8%AD%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%95%B0%E7%BB%84%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%9F%20/","excerpt":"","text":"vue2数组并没有使用Object.defineProperty重新定义数组的每个属性，vue中是怎么检测到数组的变化？ vue2缺陷无法监测数组的新增无法监测用索引改变数组的操作 方法：push，pop，shift，unshift，sort，splice，reverse 1.数组的方法（以上7个）都可以更改了数组的内容，然后更新就好了 2.vue中对数组的原型方法进行了重写，使用函数劫持的方式，重写了数组的方法 3.vue 将 data 中的数组，进行了原型链重写。通过原型链指向了自己定义的数组原型方法，这样当调用数组 api 时，可以通知依赖更新.如果数组中包含着引用类型。会对数组中的引用类型再次进行监控。 实际用vue开发时，对于响应式数组，使用push、splice、pop等方法改变数组时，页面会及时体现这种变化 Vue3是用Proxy来进行对象、数组的代理","categories":[],"tags":[]},{"title":"new article","slug":"new-article","date":"2022-03-25T10:28:45.000Z","updated":"2022-03-25T10:29:08.498Z","comments":true,"path":"2022/03/25/new-article/","link":"","permalink":"http://example.com/2022/03/25/new-article/","excerpt":"","text":"你好啊，哈哈","categories":[],"tags":[]},{"title":"三十七个常见Vue面试题","slug":"三十七个常见Vue面试题，背就完事了。","date":"2022-03-25T10:28:45.000Z","updated":"2022-03-26T01:32:30.690Z","comments":true,"path":"2022/03/25/三十七个常见Vue面试题，背就完事了。/","link":"","permalink":"http://example.com/2022/03/25/%E4%B8%89%E5%8D%81%E4%B8%83%E4%B8%AA%E5%B8%B8%E8%A7%81Vue%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%8C%E8%83%8C%E5%B0%B1%E5%AE%8C%E4%BA%8B%E4%BA%86%E3%80%82/","excerpt":"","text":"一、谈谈你对MVVM的理解？映射关系简化，隐藏controllerMVVM在MVC的基础上，把控制层隐藏掉了。 Vue不是一个MVVM框架，它是一个视图层框架。ViewModal是一个桥梁，将数据和视图进行关联。 二、谈谈你对Vue中响应式数据的理解？数组和对象类型的值变化的时候，通过defineReactive方法，借助了defineProperty，将所有的属性添加了getter和setter。用户在取值和设置的时候，可以进行一些操作。缺陷：只能监控最外层的属性，如果是多层的，就要进行全量递归。get里面会做依赖搜集（dep[watcher, watcher]）set里面会做数据更新（notify，通知watcher更新） 三、Vue中如何检测数组的变化？vue中对数组没有进行defineProperty，而是重写了数组的7个方法。分别是： pushshiftpopspliceunshiftsortreverse 因为这些方法都会改变数组本身。数组里的索引和长度是无法被监控的。 四、Vue中如何进行依赖收集的？Vue初始化的时候，挂载之后会进行编译。生成renderFunction。当取值的时候，就会搜集watcher，放到dep里面。当用户更改值的时候，就会通知watcher，去更新视图。 五、如何理解Vue中的模板编译原理？这个问题的核心是如何将template转换成render函数。 将template模块转换成ast语法书 - parserHTML对静态语法做标记（某些节点不改变）重新生成代码 - codeGen,使用with语法包裹字符串 六、Vue生命周期钩子是如何实现的?Vue的生命周期钩子是回调函数，当创建组件实例的过程中会调用相应的钩子方法。内部会对钩子进行处理，将钩子函数维护成数组的形式。 七、Vue组件生命周期有哪些？beforeCreate 在实例初始化之后，数据观测observer 和event、watcher事件配置之前被调用created 实例已经创建完成，在这一步，以下配置被完成 数据观测属性和方法的运算watch&#x2F;event时间回调$el尚未生成 beforeMount 在挂载之前被调用，render尚未被调用mounted el被新创建的vm.$el替换，并挂载到实例上去之后调用beforeUpdate 数据更新时，被调用，发生在虚拟Dom重新渲染和打补丁之前update 由于数据更改导致的虚拟Dom重新渲染和打补丁，在这之后调用beforeDestroy 实例销毁之前调用destroyed 实例销毁之后调用，调用后Vue实例的所有东西都会被解绑，所有的事件监听会被移除，子实例被销毁，该钩子在服务端渲染期间不被调用keep-alive（activated &amp; deactivated） 八、vue.mixin的使用场景和原理?Vue的mixin的作用就是抽离公共的业务逻辑，原理类似对象的继承，当组件初始化的时候，会调用mergeOptions方法进行合并，采用策略模式针对不同的属性进行合并。如果混入的数据和本身组件的数据有冲突，采用本身的数据为准。缺点：命名冲突、数据来源不清晰 九、Vue的组件data为什么必须是一个函数?new Vue是一个单例模式，不会有任何的合并操作，所以根实例不必校验data一定是一个函数。组件的data必须是一个函数，是为了防止两个组件的数据产生污染。如果都是对象的话，会在合并的时候，指向同一个地址。而如果是函数的时候，合并的时候调用，会产生两个空间。 十、请说明nextTick的原理。nextTick是一个微任务。 nextTick中的回调是在下次Dom更新循环结束之后执行的延迟回调可以用于获取更新后的DomVue中的数据更新是异步的，使用nextTick可以保证用户定义的逻辑在更新之后执行 十一、computed和watch的区别是什么？computed和watch都基于watcher来实现的。computed的属性是具备缓存的，依赖的值不发生变化，对其取值时计算属性方法不会重复执行watch是监控值的变化，当值发生改变的时候，会调用回调函数 十二、Vue.set方法是如何实现的？vue给对象和数组本身都增加了dep属性当给对象新增不存在的属性的时候，就会触发对象依赖的watcher去更新当修改数组索引的时候，就调用数组本身的splice方法去更新数组 十三、Vue为什么要用虚拟Dom虚拟dom就是用js对象来描述真实Dom，是对真实Dom的抽象由于直接操作Dom性能低，但是js层的操作效率高，可以将Dom操作转化成对象操作。最终通过diff算法比对差异进行更新Dom虚拟Dom不依赖真实平台环境，可以实现跨平台 十四、Vue的diff算法原理是什么？Vue的diff算法是平级比较，不考虑跨级比较的情况。内部采用深度递归的方式+双指针方式比较 先比较两个节点是不是相同节点相同节点比较属性，复用老节点先比较儿子节点，考虑老节点和新节点儿子的情况优化比较：头头、尾尾、头尾、尾头比对查找，进行复用 十五、既然vue通过数据劫持可以精准的探测数据变化，为什么还要进行diff检测差异？响应式数据变化，Vue确实可以在数据变化的时候，响应式系统可以立刻得知。但是如何每个属性都添加watcher的话，性能会非常的差。粒度过细，会导致更新不精准 所以采用watcher + Diff算法来检测差异。 十六、请说明key的作用和原理Vue在patch过程中，通过key可以判断两个虚拟节点是否是相同节点。没有key会导致更新的时候出问题尽量不要采用索引作为key 十七、谈谈对组件的理解组件化开发能大幅提高应用开发效率、测试性、复用性常用的组件化技术：属性、自定义事件、插槽降低更新范围，值重新渲染变化的组件高内聚、低耦合、单向数据流 十八、请描述组件的渲染流程产生组件虚拟节点 -&gt; 创建组件的真实节点 -&gt; 插入到页面 十九、请描述组件的更新流程属性更新会触发patchVnode方法，组件的虚拟节点会调用prepatch钩子，然后更新属性，更新组件。 二十、异步组件原理先渲染异步占位符节点 -&gt; 组件加载完毕后调用forceUpdate强制更新。 二十一、函数组件的优势和原理函数式组件的特性：无状态、无生命周期、无this。因此性能会高一点。 正常的一个组件是一个类继承了Vue。函数式组件，就是一个普通的函数。 二十二、组件的传值方式有哪些？props和emit:父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过emit: 父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过emit:父组件向子组件传递数据，通过prop传递。子组件传递数据给父组件是通过emit事件parent,parent,parent,children获取当前组件的父组件和当前组件的子组件attrs和attrs和attrs和listeners 。父组件通过provide提供，子组件通过inject注入变量$ref获取实例eventBus平级组件数据传递Vuex 二十三、$attrs是为了解决什么问题出现的？主要作用是为了实现批量传递数据。provide&#x2F;inject更适合应用在插件中，主要实现跨级数据传递。 二十四、v-for和v-if哪个优先级更高？首先，v-for和v-if 不能在同一个标签中使用。先处理v-for，再处理v-if。如果同时遇到的时候，应该考虑先用计算属性处理数据，在进行v-for，可以减少循环次数。 二十五、v-mode是如何实现的？在组件上用的v-model，是model和callback 在普通元素上用v-model，会生成指令，还可能因为不同的元素： 生成value和input生成change和radio生成change和checked 指令在什么时候会调用？ 源码： 二十六、Vue的普通Slot以及作用域Slot的区别普通插槽普通插槽是渲染后做替换的工作。父组件渲染完毕后，替换子组件的内容。 在模板编译的时候，处理组件中的子节点和slot标签 在创建元素的时候，用_t()方法方法来替换_v()的内容。 作用域插槽作用域插槽可以拿到子组件里面的属性。在子组件中传入属性然后渲染。 作用域插槽的编译结果： 二十八、Vue.use是干什么的？Vue.use是用来使用插件的。我们可以在插件中扩展全局组件、指令、原型方法等。会调用install方法将Vue的构建函数默认传入，在插件中可以使用vue，无需依赖vue库 二十九、组件写name有啥好处？增加name属性，会在components属性中增加组件本身，实现组件的递归调用。可以表示组件的具体名称，方便调试和查找对应的组件。 三十、vue的修饰符有哪些？.stop.prevent.capture.self.once.passive.right.center.middle.alt 三十一、如何理解自定义指令？在生成ast语法树时，遇到指令会给当前元素添加directives属性通过genDirectives生成指令代码在patch前，将指令的钩子提取到cbs中，在patch过程中调用对应的钩子当执行cbs对应的钩子时，调用对应指令定义方法 三十二、keep-alive平时在哪里使用？原理是什么？使用keep-alive包裹动态组件时，会对组件进行缓存，避免组件重新创建 使用有两个场景，一个是动态组件，一个是router-view 这里创建了一个白名单和一个黑名单。表明哪些需要需要做缓存，哪些不需要做缓存。以及最大的缓存个数。 缓存的是组件的实例，用key和value对象保存。加载的时候，监控include和exclude。 如果不需要缓存，直接返回虚拟节点。如果需要缓存，就用组件的id和标签名，生成一个key，把当前vnode的instance作为value，存成一个对象。这就是缓存列表如果设置了最大的缓存数，就删除第0个缓存。新增最新的缓存。并且给组件添加一个keepAlive变量为true，当组件初始化的时候，不再初始化。 三十三、vue-router有几种钩子函数？执行流程如何？钩子函数有三种： 全局守卫路由守卫组件守卫 三十四、vuerouter的两种模式的区别vue-router中有三种模式，分别是hash、history、abstractabstract在不支持浏览器的API换景使用hash模式兼容性好，但是不美观，不利于SEOhistory美观，historyAPI+popState，但是刷新会出现404 三十五、谈谈Vue的性能优化有哪些？数据层级不要过深，合理的设置响应式数据使用数据时，缓存值的结果，不频繁取值合理设置keyv-show(频繁切换性能高)和v-if的合理使用控制组件的粒度 -&gt; Vue采用组件级别更新采用函数式组件 -&gt; 函数式组价开销低采用异步组件 -&gt; 借助webpack的分包策略使用keep-alive来缓存组件虚拟滚动、时间分片等策略打包优化 三十六、谈谈你对Vuex的理解？Vuex是专门为vue提供的全局状态管理系统，用于多个组件中的数据共享、数据缓存。问题：无法持久化。 mutation 主要修改状态，同步执行action 执行业务代码，方便复用，逻辑可以为异步。不能直接修改状态。 三十七、vue中使用了哪些设计模式？单例模式：new多次，只有一个实例 工场模式：传入参数就可以创建实例（虚拟节点的创建）发布订阅模式：eventBus观察者模式：watch和dep代理模式：_data属性、proxy、防抖、节流中介者模式：vuex策略模式外观模式","categories":[],"tags":[]}],"categories":[],"tags":[]}